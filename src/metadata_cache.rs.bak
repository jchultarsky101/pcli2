//! Cache for metadata fields to avoid repeated API calls
//! 
//! This cache stores metadata field data locally to avoid expensive API calls when
//! checking if metadata fields exist. It caches the list of registered metadata
//! fields for each tenant.

use crate::cache::BaseCache;
use crate::model::MetadataFieldListResponse;
use crate::physna_v3::PhysnaApiClient;
use std::fs;
use std::path::PathBuf;
use tracing::{debug, trace, warn};
use serde_json;

/// Cache for metadata field data to avoid repeated API calls
/// 
/// This cache stores metadata field data locally to avoid expensive API calls when listing metadata fields.
pub struct MetadataCache {
    base: BaseCache,
}

impl Default for MetadataCache {
    fn default() -> Self {
        Self {
            base: BaseCache::new(),
        }
    }
}

impl MetadataCache {

    /// Get the cache file path for metadata by tenant
    /// 
    /// # Arguments
    /// * `tenant_id` - The tenant ID to get the cache file for
    /// 
    /// # Returns
    /// * `PathBuf` - The path to the metadata cache file for the tenant
    fn get_cache_file_path(tenant_id: &str) -> PathBuf {
        let cache_dir = BaseCache::get_cache_dir();
        BaseCache::get_cache_file_path(&cache_dir, &format!("metadata_{}", tenant_id), "json")
    }

    /// Load tenant metadata cache from file
    /// 
    /// # Arguments
    /// * `tenant_id` - The tenant ID to load cache for
    /// 
    /// # Returns
    /// * `Ok(Some(MetadataFieldListResponse))` - The loaded metadata if cache exists and is valid
    /// * `Ok(None)` - If cache doesn't exist or is expired
    /// * `Err` - If there was an error reading the cache
    fn load_tenant_cache(tenant_id: &str) -> Result<Option<MetadataFieldListResponse>, Box<dyn std::error::Error>> {
        let cache_file = Self::get_cache_file_path(tenant_id);
        
        if cache_file.exists() && !BaseCache::is_file_expired(&cache_file) {
            let data = fs::read_to_string(&cache_file)?;
            let response: MetadataFieldListResponse = serde_json::from_str(&data)?;
            debug!("Loaded metadata cache for tenant: {}", tenant_id);
            Ok(Some(response))
        } else {
            Ok(None)
        }
    }

    /// Save tenant metadata to cache file
    /// 
    /// # Arguments
    /// * `tenant_id` - The tenant ID to save cache for
    /// * `response` - The metadata field list response to cache
    /// 
    /// # Returns
    /// * `Ok(())` - If the cache was successfully saved
    /// * `Err` - If there was an error saving the cache
    fn save_tenant_cache(tenant_id: &str, response: &MetadataFieldListResponse) -> Result<(), Box<dyn std::error::Error>> {
        let cache_file = Self::get_cache_file_path(tenant_id);
        
        // Create directory if it doesn't exist
        if let Some(parent) = cache_file.parent() {
            fs::create_dir_all(parent)?;
        }
        
        let data = serde_json::to_string_pretty(response)?;
        fs::write(&cache_file, data)?;
        debug!("Saved metadata cache for tenant: {}", tenant_id);
        Ok(())
    }

    /// Get metadata fields for a tenant, fetching from API if not cached or expired
    /// 
    /// # Arguments
    /// * `client` - The Physna API client
    /// * `tenant_id` - The ID of the tenant
    /// * `refresh` - Whether to force refresh the cache
    /// 
    /// # Returns
    /// * `Ok(MetadataFieldListResponse)` - The metadata fields for the tenant
    /// * `Err` - If there was an error during API calls
    pub async fn get_or_fetch(
        client: &mut PhysnaApiClient, 
        tenant_id: &str, 
        refresh: bool
    ) -> Result<MetadataFieldListResponse, Box<dyn std::error::Error + Send + Sync>> {
        trace!("Getting or fetching metadata fields for tenant: {}", tenant_id);
        
        // Check if we should use cache
        if !refresh {
            if let Ok(Some(cached_response)) = Self::load_tenant_cache(tenant_id) {
                trace!("Using existing cache for tenant: {}", tenant_id);
                return Ok(cached_response);
            } else {
                trace!("No cache found or cache expired for tenant: {}, fetching from API", tenant_id);
            }
        } else {
            trace!("Refresh requested, fetching metadata fields from API for tenant: {}", tenant_id);
        }
        
        // Fetch from API
        let metadata_fields_response = client.get_metadata_fields(tenant_id).await
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)?;
        
        // Update cache
        if let Err(e) = Self::save_tenant_cache(tenant_id, &metadata_fields_response) {
            warn!("Failed to save metadata cache: {}", e);
        }
        
        Ok(metadata_fields_response)
    }

    /// Get cached metadata fields for a tenant if available and not expired
    /// 
    /// # Arguments
    /// * `tenant_id` - The ID of the tenant
    /// 
    /// # Returns
    /// * `Some(MetadataFieldListResponse)` - If metadata fields are cached and not expired
    /// * `None` - If metadata fields are not cached or are expired
    pub fn get_cached_metadata_fields(&self, tenant_id: &str) -> Option<MetadataFieldListResponse> {
        match Self::load_tenant_cache(tenant_id) {
            Ok(Some(response)) => Some(response),
            _ => None,
        }
    }

    /// Invalidate cache for a specific tenant
    /// 
    /// This method removes cached metadata fields for the specified tenant from the cache.
    /// This is useful after creating new metadata fields to ensure consistency between 
    /// local cache and remote API.
    /// 
    /// # Arguments
    /// * `tenant_id` - The ID of the tenant whose cache to invalidate
    /// 
    /// # Returns
    /// * `true` if cache entry was removed, `false` if no entry existed
    pub fn invalidate_tenant(&mut self, tenant_id: &str) -> bool {
        let cache_file = Self::get_cache_file_path(tenant_id);
        if cache_file.exists() {
            match fs::remove_file(&cache_file) {
                Ok(_) => {
                    trace!("Invalidated metadata cache for tenant {}", tenant_id);
                    true
                }
                Err(_) => false,
            }
        } else {
            false
        }
    }
}

impl MetadataCache {
    /// Invalidate tenant metadata cache statically (without loading the full cache)
    /// 
    /// This method removes the cached metadata for the specified tenant without
    /// loading the entire cache, making it more efficient for simple invalidation.
    /// 
    /// # Arguments
    /// * `tenant_id` - The ID of the tenant whose cache to invalidate
    /// 
    /// # Returns
    /// * `true` if cache entry was removed, `false` if no entry existed
    pub fn invalidate_tenant_static(tenant_id: &str) -> bool {
        let cache_file = Self::get_cache_file_path(tenant_id);
        if cache_file.exists() {
            match fs::remove_file(&cache_file) {
                Ok(_) => {
                    trace!("Invalidated metadata cache for tenant {}", tenant_id);
                    true
                }
                Err(_) => false,
            }
        } else {
            false
        }
    }

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_metadata_cache_get_cache_file_path() {
        // Test that we can get the cache file path for a tenant
        let cache_file = MetadataCache::get_cache_file_path("test-tenant");
        assert!(cache_file.ends_with("pcli2/metadata_test-tenant.json"));
    }

    #[test]
    fn test_metadata_cache_invalidate_nonexistent() {
        // Test that we can invalidate a cache file that doesn't exist
        let temp_dir = TempDir::new().unwrap();
        
        // Temporarily override the cache directory
        std::env::set_var("PCLI2_TEST_CACHE_DIR", temp_dir.path());
        
        // This should not panic or return an error
        let cache_dir = MetadataCache::get_cache_file_path("nonexistent-tenant");
        if cache_dir.exists() {
            let _ = fs::remove_file(&cache_dir);
        }
        
        // Clean up
        std::env::remove_var("PCLI2_TEST_CACHE_DIR");
    }
}

#[cfg(test)]
mod tests {